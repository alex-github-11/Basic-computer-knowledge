01 ｜ 基础架构
1、MySQL一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。

连接器：负责跟客户端建立连接、获取权限、维持和管理连接。数据库里面的连接分为长连接和短连接，尽量使用长连接。

数据库异常重启，是因为MYSQL的内存是管理在连接对象里面的，长连接会耗尽内存空间。可以采用两种方法：第一种定期断开长连接，第二种：通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证， 但是会将连接恢复到刚刚创建完时的状态。

查询缓存：之前执行过的语句及其结果会以key-value对的形式，被直接缓存在内存中。不建议使用查询缓存，因为利大于弊。查询缓存的失效十分频繁，只要有对一个表的更新，这个表上的所有查询缓存都会被清空。建议静态表使用查询缓存。

分析器：词法和语法分析。

优化器：执行计划生成，索引选择。当存在多个表关联时，决定各个表的连接顺序。

2、MySQL可以分为Server层和存储引擎两部分。

3、Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

4、存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。

02 ｜ 日志系统：一条SQL语句是如何更新的？
MYSQL分为两部分：server层和INNODB引擎层，binlog（归档日志属于server层，逻辑），redo log 日志（物理）是属于引擎层的日志。具有crash-safe能力，两阶段提交。保证数据库数据的统一性。

03 ｜ 事物隔离：为什么你改了我还看不见？
事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。
事务具有：ACID：即原子性、一致性、隔离性、持久性。
当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantomread）的问题，为了解决这些问题，就有了“隔离级别”的概念。
SQL标准的事务隔离级别包括：读未提交（read uncommitted）、 读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。 
读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 
读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 
可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 
串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 
在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

1.事务隔离的实现：在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
2、同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。
3、为什么建议你尽量不要使用长事务。回滚记录大量占用存储空间。
4、MySQL的事务启动方式有以下几种： 1. 显式启动事务语句，begin 或 start transaction。配套的提交语句是commit，回滚语句是 rollback。 2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。


04 ｜ 索引：深入浅出索引？
1、索引的结构模型分为三类：哈希表、有序数组、搜索树
2、哈希表：这种结构只适用于只有等值查询的场景，不适用于范围查询。
3、有序数组在等值查询和范围查询场景中的性能都十分优秀。仅仅看查询效率，有序数组就是最好的数据结构了。有序数组只适用于静态存储引擎，对于需要更新的数据不实用。
4、二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。MySQL使用B+树。
5、N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。
6、在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。每一个索引在InnoDB里面对应一棵B+树。
7、根据叶子节点的内容，索引类型分为主键索引和非主键索引，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。普通索引到主键索引搜索的过程称为回表。
8、自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOTNULL PRIMARY KEY AUTO_INCREMENT。
9、了InnoDB采用的B+树结构，以及为什么 InnoDB要这么选择。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

05 ｜ 深入浅出索引（下）？
1、如何减少回表次数，可以采用覆盖索引，可以减少树的搜索次数，显著提升查询效率。
2、B+树这种索引结构可以利用索引的“最左前缀”，来定位记录。
3、索引下推，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

06 ｜全局锁和表锁，给表加个字段怎么会有这么多的阻碍？
1、数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访 问规则的重要数据结构。
2、根据加锁的范围，MySQL里面的锁大致可以分为三类：全局锁、表级锁、行锁。
3、全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。全局锁一般用于当需要整个数据库处于只读状态时，全局锁的应用场景就是当需要做全库逻辑备份。
4、MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
5、在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。
6、MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

07 ｜ 行锁功过：怎么减少行锁对性能的影响？
1、MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。
2、在INNODB事务中，行锁是在有需要的时候加上，但不是在不需要的时候就立刻释放，而是当事务提交了之后再释放。这个就是两阶段锁协议。
3、如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
4、当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。
5、当出现死锁以后，有两种策略： 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout来设置。 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。
6、怎么解决由这种热点行更新导致的性能问题呢？（由于死锁检测）
   一种是把死锁检测关掉，第二种就是减少并发度。

08 ｜ 事务到底是隔离还是不隔离的？

07 | 行锁功过：怎么减少行锁对性能的影响？
MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM引擎就不支持行锁。
两阶段锁协议：在事物中，行锁是在需要的时候才加上的，但不是在不需要的时候就释放，而是在事务结束的时候才关闭行锁。
如果你的事务中需要锁多个行，要把 最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
死锁和死锁检测：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致 这几个线程都进入无限等待的状态，称为死锁。

INoDB 利用了“所有数据都有多个版本的特性”，实现了秒级创建快照的能力。


10 | MySQL为什么有时候会选错索引？
1、这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL竟然会选错索引。
2、选择索引是优化器的工作。优化器的判断标准主要是扫描行数、是否使用临时表、是否排序等综合判断。
3、扫描行数是怎么判断的？一个索引上不同的值越多，这个索引的区分度就越 好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越 大，索引的区分度越好
4、MySQL是怎么得到索引的基数的呢？采样统计的方法。InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。
5、如果只是索引统计不准确，通过analyze命令可以解决很多问题。
6、索引选择异常和处理：
   采用force index强行选择一个索引。
   我们可以考虑修改语句，引导MYSQL使用我们期望的索引。
   再有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删除掉误用的索引。
